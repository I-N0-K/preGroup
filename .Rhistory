x <- x[!(is.na(x))]
return((sum(((x-mean(x))/sd(x))^3))/length(x))
}
kurtosis <- function(x) {
x <- x[!(is.na(x))]
return((sum(((x-mean(x))/sd(x))^4))/length(x))
}
is_categorical <- function(col_test, categorical_cutoff = 10) {
col_test <- col_test[!is.na(col_test)]
if (length(unique(col_test[!(is.na(col_test))])) <= categorical_cutoff)  {
return(TRUE)
} else {
return(FALSE)
}
}
is_continuous <- function(col_test, categorical_cutoff  = 10) {
return(!is_categorical(col_test, categorical_cutoff))
}
is_skewed <- function(col_test, categorical_cutoff = 10, skewness_cutoff = 0.8, kurtosis_cutoff = 0.8) {
if(is_continuous(col_test, categorical_cutoff) &
(abs(skewness(col_test)) > skewness_cutoff) &
(abs(kurtosis(col_test)) > kurtosis_cutoff)) {
return(TRUE)
} else {
return(FALSE)
}
}
is_nomally_distributed <- function(col_test) {
col_test <- col_test[!is.na(col_test)]
return(!is_skewed(col_test))
}
continuous_summary <- function(target_col) {
target_col <- target_col[!is.na(target_col)]
return(c(
round(mean(target_col), digits = 2),
round(sd(target_col), digits = 2),
range(target_col)))
}
skewed_summary <- function(target_col) {
target_col <- target_col[!is.na(target_col)]
return(c(median(target_col), IQR(target_col), range(target_col)))
}
categorical_summary <- function(target_col) {
# There is a weird bug: The variable name in table()/length() is printed into the output,
# but there seems no way to fix it
# So we use magic to solve this bug: name it into "Proportions"
Proportions <- target_col[!is.na(target_col)]
props <- table(Proportions)/length(Proportions)
return(round(props, digits = 2))
}
count_nmiss <- function(target_col) {
return(sum(is.na(target_col)))
}
# Most of this part are functions from the assignments
# This is the base for the the advanced parts
# Contents
# 1. A function to get the mathematic mode
# 2. functions for data type examination
# 3. summary for skewed, continuous, and categorical vectors
# 4. count N_missing
mode_stats <- function(x) {
# Got this one online
# https://www.statology.org/mode-in-r/
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
# An alternative:
# https://stackoverflow.com/questions/2547402/how-to-find-the-statistical-mode
# return(names(sort(-table(x)))[1])
}
skewness <- function(x) {
x <- x[!(is.na(x))]
return((sum(((x-mean(x))/sd(x))^3))/length(x))
}
kurtosis <- function(x) {
x <- x[!(is.na(x))]
return((sum(((x-mean(x))/sd(x))^4))/length(x))
}
is_categorical <- function(col_test, categorical_cutoff = 10) {
col_test <- col_test[!is.na(col_test)]
if (length(unique(col_test[!(is.na(col_test))])) <= categorical_cutoff)  {
return(TRUE)
} else {
return(FALSE)
}
}
is_continuous <- function(col_test, categorical_cutoff  = 10) {
return(!is_categorical(col_test, categorical_cutoff))
}
is_skewed <- function(col_test, categorical_cutoff = 10, skewness_cutoff = 0.8, kurtosis_cutoff = 0.8) {
if(is_continuous(col_test, categorical_cutoff) &
(abs(skewness(col_test)) > skewness_cutoff) &
(abs(kurtosis(col_test)) > kurtosis_cutoff)) {
return(TRUE)
} else {
return(FALSE)
}
}
is_nomally_distributed <- function(col_test) {
col_test <- col_test[!is.na(col_test)]
return(!is_skewed(col_test))
}
continuous_summary <- function(target_col) {
target_col <- target_col[!is.na(target_col)]
return(c(
round(mean(target_col), digits = 2),
round(sd(target_col), digits = 2),
range(target_col)))
}
skewed_summary <- function(target_col) {
target_col <- target_col[!is.na(target_col)]
return(c(median(target_col), IQR(target_col), range(target_col)))
}
categorical_summary <- function(target_col) {
# There is a weird bug: The variable name in table()/length() is printed into the output,
# but there seems no way to fix it
# So we use magic to solve this bug: name it into "Proportions"
Proportions <- target_col[!is.na(target_col)]
props <- table(Proportions)/length(Proportions)
return(round(props, digits = 2))
}
count_nmiss <- function(target_col) {
return(sum(is.na(target_col)))
}
setwd("C:\\AnalysesToolBox\\FinalAssignment_Kaiwen\\20221026_FinalVersion")
source("C:/AnalysesToolBox/FinalAssignment_Kaiwen/20221026_FinalVersion/Extra_Stats_Functions.R", echo=TRUE)
# This part is about to generate a descriptives overview of a dataframe
# It's faster and more reliable than the one from the assignments
# Feel free to experiment with different datasets
# Contents:
# 1. Select and rename target varables into a new dataframe for further analysis
# 2. Build a template of descriptives tables
# 3. Examine the variable type
# 4. Generate relevant statistics for different types of variables
# 5. Customize layout (Sort variables by type)
# 6. Return all descriptives in one list, to combine with the result section later.
# Select and rename target varables into a new dataframe for further analysis
# This saves the effort of manual subsetting
select_target_variables <- function(df_input, target_variables, new_names = target_variables) {
target_df <- data.frame(matrix(nrow = nrow(df_input), ncol = 0))
for (i in 1:length(target_variables)) {
target_df[, target_variables[i]] <- df_input[, target_variables[i]]
# print(i)
}
colnames(target_df) <- new_names
# print("here")
return(target_df)
}
examine_vtype <- function(target_variable, categories_cutoff = 10) {
# The "Undefined" type applies to "noise" variables (e.g., date or id),
# which are "non-numeric" (strings, characters) and have numerous unique values (>> categorical_cutoff).
# Filter them out before getting errors from "calculating the means of string variables"
if ((!is.numeric(target_variable)) & (!is_categorical(target_variable, categorical_cutoff = categories_cutoff))) {
return("Undefined")
# Both numeric / non-numeric varables are categorical, if the unique value <= categorical cutoff
} else if (is_categorical(target_variable, categorical_cutoff = categories_cutoff)) {
return("Categorical")
# For numeric variables with unique values >> categorical_cutoff,
# specify the type based on skewness & kurtosis
} else if (is_skewed(target_variable, categorical_cutoff = categories_cutoff)) {
return("Skewed")
} else {
return("Continuous")
}
}
# Design the template of the descriptives table before calculating the statistics
# Seperate template from content = Easier to debug
# The df_input seems redundant, but it provides a way to generate a template directly from a dataframe
# without additional selections
generate_descriptives_template <- function(df_input, variable_rows = colnames(df_input), categorical_cutoff = 10) {
df_layout <- list(row_labels = variable_rows,
column_labels = c("Type","N_missing","Mean", "SD", "Median", "IQR", "Min", "Max", "Mode"))
descriptives_template <- data.frame(matrix(NA,
nrow = length(df_layout[["row_labels"]]),
ncol = length(df_layout[["column_labels"]]),
dimnames = df_layout[c("row_labels", "column_labels")],
byrow = FALSE))
return(descriptives_template)
}
# Return a descriptives list, with
# 1.The overview of all variables
# 2.Proportion tables for each categorical variable
generate_descriptives <- function(df_input, target_variables = colnames(df_input), n_categories = 10,
rearrange_by_type = FALSE, remove_undefined = FALSE) {
# Generate the template first before calculating the specific values for different types;
# The Type and N_missing applies to all variables, so calculate it here
df_summary <- generate_descriptives_template(df_input, variable_rows = target_variables, categorical_cutoff = n_categories)
# print(df_summary)
for (i in 1:length(target_variables)) {
# print(length(target_variables))
# print(df_input[, target_variables[i]])
# df_input[, target_variables[i]]
df_summary[i, "Type"] <- examine_vtype(target_variable = df_input[, target_variables[i]], categories_cutoff = n_categories)
df_summary[i, "N_missing"] <- count_nmiss(df_input[, target_variables[i]])
}
# print(df_summary)
# Generate this Temporary_vName for further boolean indexing and cleaning
# because it's difficult to retrieve the rowname by booleans in one line code
df_summary[, "Temporary_vName"] <- rownames(df_summary)
# print(df_summary)
# Rearrange the df_summary table based on data types if needed
df_summary <- format_df_summary(df_summary, rearrange_by_type, remove_undefined)
# Write the specific statistics for skewed & continuous variables into the df_summary table
for(skewed_variables in df_summary[(df_summary[, "Type"] == "Skewed"), "Temporary_vName"]) {
df_summary[skewed_variables, c("Median", "IQR", "Min", "Max")] <- skewed_summary(df_input[, skewed_variables])
}
for(continuous_variables in df_summary[(df_summary[, "Type"] == "Continuous"), "Temporary_vName"]) {
df_summary[continuous_variables, c("Mean", "SD", "Min", "Max")] <- continuous_summary(df_input[, continuous_variables])
}
# For categorical variables the procedures are a bit different.
# 1. calculate the mode and write it on the df_summary table
# 2. Make separate props table and pack them into a categorical_props_list
# The category names are informative but distinct across different variables
categorical_props_list <- list()
for(categorical_variables in df_summary[(df_summary[, "Type"] == "Categorical"), "Temporary_vName"]) {
df_summary[categorical_variables, "Mode"] <- mode_stats(df_input[, categorical_variables])
categorical_props_list[[categorical_variables]] <- categorical_summary(df_input[, categorical_variables])
# print(categorical_props_list[[categorical_variables]])
}
# Remove the Temporary_vName after the boolean indexing so it won't show up in the output
df_summary[, "Temporary_vName"] <- NULL
# Combine the df_summary table and non-empty categorical_props_list into a final summary list
if(length(categorical_props_list) != 0) {
df_summary_list <- list(Overview_Descriptives = df_summary,
Categorical_Props = categorical_props_list)
} else {
df_summary_list <- list(Overview_Descriptives = df_summary)
}
return(df_summary_list)
}
format_df_summary <- function(df_summary, rearrange_by_type, remove_undefined) {
# Rearrange the df_summary table based on data types if needed
if(rearrange_by_type == TRUE) {
df_summary <- rbind(df_summary[(df_summary[, "Type"] == "Skewed"), ],
df_summary[(df_summary[, "Type"] == "Continuous"), ],
df_summary[(df_summary[, "Type"] == "Categorical"), ],
df_summary[(df_summary[, "Type"] == "Undefined"), ])
}
# Remove the "Undefined" Variables if needed
if(remove_undefined == TRUE) {
df_summary <- df_summary[(df_summary[, "Type"] != "Undefined"), ]
}
return(df_summary)
}
# This part is about writing an summary based on lm anova table
# and saving them
# Input  A. an lm Anova table, B. whether to interpret interaction
# Contents:
# 1. Detect the X and Y variables from the lm Anova table
# 2. Generate the followings:
#     The (significant?) relationship between X and Y
#     F(df1, df2) = f
#     p = ?
#     effect size / partial eta squared = ?
write_summary_lm_anova <- function(anova_table, interpret_interaction = FALSE) {
# The order for x's may differ, depending on whether the user wants to interpret the interaction
x_variables <- order_interpretation(anova_table, interpret_interaction)
# Y and df2 are constants; save them here
y_variable <- get_y_name_anova(anova_table)
df_residuals <- anova_table["Residuals", "Df"]
# create a matrix to save the summary
summary_anova <- matrix(NA, nrow = length(x_variables), ncol = 1, dimnames = NULL)
for (i in 1:(length(x_variables))) {
# Note: df1, f, p, significance, effect size / partial eta squared differs per X
# So calculate them in the loop
# print(partial_eta_squared)
f_value <- anova_table[i, "F value"]
df1 <- anova_table[i, "Df"]
p_value <- anova_table[i, "Pr(>F)"]
partial_eta_squared <- apa_format_value((anova_table[i, "Sum Sq"])
/(anova_table[i, "Sum Sq"] + anova_table["Residuals", "Sum Sq"]))
# print(p_value)
# Interpret the significance based on p_value, and round statistics to apa-format digits
summary_anova[i, 1] <- paste0(x_variables[i], " is ", apa_significance(p_value)," correlated with ", y_variable,
", F(", df1, ", ", df_residuals, ")", apa_format_value(f_value),
", p", apa_format_value(p_value, digits = 3),
", partial eta squared", partial_eta_squared, ".")
# print(i)
}
return(summary_anova)
}
# Extract the name of y variable from a R anova table via attr()
get_y_name_anova <- function(anova_table_input) {
y_name <- stringr::str_replace(string = attr(anova_table_input, "heading")[2],
pattern = "Response: ",
replacement = "")
return(stringr::str_to_lower(y_name))
}
# Get the order of x variables for interpretation
order_interpretation <- function(anova_table_ws, interpret_interation_ws = FALSE) {
x_variables <- rownames(anova_table_ws)
x_variables <- x_variables[!(x_variables == "Residuals")]
# print(x_variables)
# The key to distinguish the interaction term from main effects is ":"
# Only interaction terms contains ":", whereas main effect terms contain pure letters.
interaction_indication <- stringr::str_detect(x_variables, pattern = ":", negate = FALSE)
if (interpret_interation_ws == FALSE) {
# Remove the interaction terms if the user does not want to interpret it
x_variables <- x_variables[!interaction_indication]
print(x_variables)
} else {
# Rearrange the order if the user wants to interpret interaction.
# "Interpret the interaction first" is the rule of thumb from statistics courses
x_variables <- c(x_variables[interaction_indication], x_variables[!interaction_indication])
# print(x_variables)
}
return(x_variables)
}
# interpret the p_value
apa_significance <- function(input_p_value) {
if(input_p_value < 0.05) {
return("significantly")
} else {
return("not significantly")
}
}
# return numbers as apa format; 3 digits for p value; default (all but p_value) is 2 digits
apa_format_value <- function(input_value, digits = 2) {
if(input_value < 0.001) {
return(" < .001")
# Bug: If input 0.002, the result will be 0 if only round to 2 digits.
# This step re-checks the rounded value and gives an extra digit if it's rounded to 0
# There seems no better altenatives
} else if (round(input_value, digits) < 0.001) {
return(paste0(" = ", round(input_value, digits + 1)))
} else {
return(paste0(" = ", round(input_value, digits)))
}
}
# Save the overall results into a file
save_analysis_result <- function(result_list, target_file = "results.txt",
append_current_file = FALSE, save_RData = FALSE) {
sink(file = target_file, append = append_current_file)
print(result_list)
sink()
print(paste("The result is saved to", target_file))
if (save_RData == TRUE) {
rda_file <- rename_to_Rda(target_file)
save(result_list, file = rda_file)
print(paste("The RData file is saved to", rda_file))
}
}
rename_to_Rda <- function(file_name) {
file_name2 <- strsplit(file_name, "\\.")[[1]][1]
# print(file_name2)
return(paste0(file_name2,".RData"))
}
source("C:/AnalysesToolBox/FinalAssignment_Kaiwen/20221026_FinalVersion/Generating_Results.R")
source("C:/AnalysesToolBox/FinalAssignment_Kaiwen/20221026_FinalVersion/Generating_Results.R")
for(i in 1:10) {
for (j in 1:10) {
a[i,j] <- max(i, j)
}
}
a <- matrix(NA, 10, 10)
# Using a for-loop/for-loop(s) turn that matrix into the following:
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
# [1,]    1    2    3    4    5    6    7    8    9    10
# [2,]    2    2    3    4    5    6    7    8    9    10
# [3,]    3    3    3    4    5    6    7    8    9    10
# [4,]    4    4    4    4    5    6    7    8    9    10
# [5,]    5    5    5    5    5    6    7    8    9    10
# [6,]    6    6    6    6    6    6    7    8    9    10
# [7,]    7    7    7    7    7    7    7    8    9    10
# [8,]    8    8    8    8    8    8    8    8    9    10
# [9,]    9    9    9    9    9    9    9    9    9    10
# [10,]  10   10   10   10   10   10   10   10   10    10
# Hint: pay attention to the relationship between row and column numbers in each cell
# I appreciate this hint. Very insightful :)
for(i in 1:10) {
for (j in 1:10) {
a[i,j] <- max(i, j)
}
}
print(a)
a <- matrix(NA, 10, 10)
# Using a for-loop/for-loop(s) turn that matrix into the following:
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
# [1,]    1    2    3    4    5    6    7    8    9    10
# [2,]    2    2    3    4    5    6    7    8    9    10
# [3,]    3    3    3    4    5    6    7    8    9    10
# [4,]    4    4    4    4    5    6    7    8    9    10
# [5,]    5    5    5    5    5    6    7    8    9    10
# [6,]    6    6    6    6    6    6    7    8    9    10
# [7,]    7    7    7    7    7    7    7    8    9    10
# [8,]    8    8    8    8    8    8    8    8    9    10
# [9,]    9    9    9    9    9    9    9    9    9    10
# [10,]  10   10   10   10   10   10   10   10   10    10
# Hint: pay attention to the relationship between row and column numbers in each cell
# I appreciate this hint. Very insightful :)
for(i in 1:10) {
for (j in 1:10) {
a[i,j] <- max(i, j)
}
}
print(a)
swirl()
library(swirl)
swirl()
1
swirl()
d1 <- Sys.Date()
class(d1)
unclass(d1)
d1
d2 <- as.Date("1969-01-01")
unclass(d2)
t1 <- Sys.time()
t1
class(t1)
unclass(t1)
t2 <- as.POSIXlt(Sys.time())
t2
class(t2)
t2
unclass(t2)
str(unclass(t2))
t2$min
knitr::opts_chunk$set(echo = TRUE)
system = 22
You can also embed plots, for example:
plot(pressure)
recommendation_info <- c("Name", "Area")
?komaletter
install.packages("vitae")
source("~/.active-rstudio-document", echo=TRUE)
holiday_budget_subunit = c("Country", "Traffic", "Hostel", "Food", "Entertainment",
"Gifts", "Travel_insurance_Vaccinations")
holiday_plan_df = data.frame(matrix(data = NA, nrow = 1, ncol = length(holiday_budget_subunit), byrow = FALSE))
View(holiday_plan_df)
holiday_plan_df = data.frame(matrix(data = NA, nrow = 1, ncol = length(holiday_budget_subunit), byrow = FALSE, dimnames = holiday_budget_subunit))
colnames(holiday_plan_df) <- holiday_budget_subunit
View(holiday_plan_df)
holiday_budget_subunit = c("Country", "Traffic", "Hostel", "Food", "Entertainment",
"Gifts", "Travel_insurance_Vaccinations","Total")
View(holiday_plan_df)
holiday_budget_subunit = c("Country", "Traffic", "Hostel", "Food", "Entertainment",
"Gifts", "Travel_insurance_Vaccinations","Total")
holiday_plan_df = data.frame(matrix(data = NA, nrow = 1, ncol = length(holiday_budget_subunit), byrow = FALSE))
colnames(holiday_plan_df) <- holiday_budget_subunit
source("C:/Users/Kaiwen/Desktop/Weightmean/statstest.R", echo=TRUE)
source("C:/Users/Kaiwen/Desktop/Weightmean/statstest.R", echo=TRUE)
# install.packages('weights')
# install.packages('installr')
# installr::updater()
# if(!require(installr)) {
#   install.packages("installr");
#   require(installr)
# }
# updateR()
# install.packages("Hmisc")
install.packages('rlang')
install.packages("rlang")
source("C:/Users/Kaiwen/Desktop/Weightmean/statstest.R", echo=TRUE)
source("C:/Users/Kaiwen/Desktop/Weightmean/statstest.R", echo=TRUE)
source("C:/Users/Kaiwen/Desktop/Weightmean/statstest.R", echo=TRUE)
source("C:/Users/Kaiwen/Desktop/Weightmean/statstest.R", echo=TRUE)
source("C:/Users/Kaiwen/Desktop/Weightmean/statstest.R", echo=TRUE)
source("C:/Users/Kaiwen/Desktop/Weightmean/statstest.R", echo=TRUE)
rm(list = ls())
library(usethis)
library(devtools)
library(roxygen2)
library(rmarkdown)
library(codetools)
# Define the package path
path_preGroup <- "C:\\Users\\Kaiwen\\desktop\\preGroup"
# Set the working directory
setwd(path_preGroup)
# Create the package structure
usethis::create_package(path_preGroup, open = FALSE)
# Add required packages to Imports
usethis::use_package("mvs")
usethis::use_package("pre")
usethis::use_package("Formula")
usethis::use_package("survival")
usethis::use_package("MatrixModels")
# Add suggested packages
usethis::use_package("ggplot2", type = "Suggests")
usethis::use_package("testthat", type = "Suggests")
usethis::use_package("knitr", type = "Suggests")
usethis::use_package("rmarkdown", type = "Suggests")
# Add VignetteBuilder
# # Create a vignette template
usethis::use_vignette("introduction")
# # Document the package using roxygen2
devtools::document(pkg = path_preGroup)
devtools::build(path_preGroup, vignettes = TRUE)
if ("package:preGroup" %in% search()) {
detach("package:preGroup", unload = TRUE)
}
?create_package
# Add required packages to Imports
usethis::use_package("mvs")
usethis::use_package("pre")
usethis::use_package("Formula")
usethis::use_package("survival")
usethis::use_package("MatrixModels")
# Add suggested packages
usethis::use_package("ggplot2", type = "Suggests")
usethis::use_package("testthat", type = "Suggests")
usethis::use_package("knitr", type = "Suggests")
usethis::use_package("rmarkdown", type = "Suggests")
rm(list = ls())
library(usethis)
library(devtools)
library(roxygen2)
library(rmarkdown)
library(codetools)
# Define the package path
path_preTreatment <- "C:\\Users\\Kaiwen\\desktop\\preTreatment"
# Set the working directory
setwd(path_preTreatment)
